# AST-grep patterns for Rust colored crate method calls
#
# Tested with: ast-grep 0.x (vendored in vendor/ast-grep)
# Language: Rust
# Purpose: Systematic refactoring of colored::Colorize methods to Theme tokens
#
# IMPORTANT LIMITATIONS:
# - ast-grep CANNOT match code inside Rust macro invocations
# - Pattern '$X.cyan()' works: let x = "text".cyan();
# - Pattern '$X.cyan()' FAILS: println!("{}", "text".cyan())  <- inside macro
# - Pattern '$X.cyan()' FAILS: format!(...).cyan()  <- macro result
# - For comprehensive refactoring, use identifier search ('cyan') + manual review

patterns:
  # Color methods (works outside macro context only)
  - id: cyan_to_highlight
    pattern: $X.cyan()
    rewrite: Theme::highlight($X)
    description: "Match .cyan() when NOT inside macro invocations"
    theme_token: highlight
    limitations: "Does NOT match code inside println!(), format!(), etc."
    examples:
      - before: 'let x = "text".cyan();'
        after: 'let x = Theme::highlight("text");'
      - before: 'let y = my_var.cyan();'
        after: 'let y = Theme::highlight(my_var);'
    non_examples:
      - 'println!("{}", "text".cyan())  # NOT matched - inside macro'
      - 'format!("{}", x).cyan()        # NOT matched - macro result with method'

  - id: green_to_success
    pattern: $X.green()
    rewrite: Theme::success($X)
    description: "Match .green() when NOT inside macro invocations"
    theme_token: success
    limitations: "Does NOT match code inside println!(), format!(), etc."
    examples:
      - before: 'let status = "OK".green();'
        after: 'let status = Theme::success("OK");'

  - id: yellow_to_warning
    pattern: $X.yellow()
    rewrite: Theme::warning($X)
    description: "Match .yellow() method calls"
    theme_token: warning
    examples:
      - before: '"Warning".yellow()'
        after: 'Theme::warning("Warning")'

  - id: red_to_error
    pattern: $X.red()
    rewrite: Theme::error($X)
    description: "Match .red() method calls"
    theme_token: error

  - id: bright_black_to_secondary
    pattern: $X.bright_black()
    rewrite: Theme::secondary($X)
    description: "Match .bright_black() method calls"
    theme_token: secondary

  # Chained methods (.bold().cyan())
  - id: bold_cyan_to_header
    pattern: $X.bold().cyan()
    rewrite: Theme::header($X)
    description: "Match .bold().cyan() chains"
    theme_token: header
    note: "Apply this BEFORE simple cyan pattern to avoid partial matches"

  # Just bold (context-dependent, may need manual review)
  - id: bold_to_label
    pattern: $X.bold()
    rewrite: Theme::label($X)
    description: "Match .bold() - may need manual review for context"
    theme_token: label
    note: "Use with caution - bold is context-dependent"

# Usage instructions:
#
# RECOMMENDED WORKFLOW (due to metavariable limitations):
#
# 1. Find ALL occurrences by method name:
#    hegel astq -l rust -p 'cyan' src/commands/
#
# 2. For simple cases, use pattern rewrite:
#    hegel astq -l rust -p '$X.cyan()' -r 'Theme::highlight($X)' --update-all src/file.rs
#
# 3. For complex cases (macros/chains), manual refactoring required:
#    - format!(...).cyan() → Theme::highlight(format!(...))
#    - x.to_string().cyan() → Theme::highlight(x.to_string())
#
# 4. Verify with tests:
#    cargo test

# Pattern application order (important!):
#
# 1. Chained methods first (.bold().cyan() before .cyan())
# 2. Specific colors (cyan, green, yellow, red)
# 3. Generic modifiers last (.bold(), .bright_black())
#
# This prevents partial replacements leaving broken chains.

# Metavariable syntax:
#
# $X - Matches any expression (literal, variable, field access, etc.)
# $$ - Escape literal $ in pattern
#
# MACRO LIMITATION - ast-grep cannot see inside Rust macros:
# - ✅ Matches: let x = "text".green();  (statement context)
# - ✅ Matches: let x = var.green();     (statement context)
# - ❌ Does NOT match: println!("{}", "text".green())  (inside macro)
# - ❌ Does NOT match: format!(...).green()            (macro result)
#
# Why? Macros aren't expanded in the tree-sitter AST, creating an opaque boundary.
# The pattern is matched against AST nodes, and macro internals aren't accessible.
#
# For finding ALL occurrences (including inside macros):
# - Search by method name only: hegel astq -l rust -p 'green' src/
# - This does identifier search, not AST pattern matching
# - Then manually refactor cases inside macros

# Testing new patterns:
#
# Use --debug-query to see AST structure:
# hegel astq -l rust --debug-query=ast -p 'your_pattern' file.rs
