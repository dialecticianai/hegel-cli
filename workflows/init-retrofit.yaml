# Retrofit initialization workflow - add DDD to existing project
mode: init
start_node: detect_existing

nodes:
  detect_existing:
    prompt: |
      You are retrofitting Dialectic-Driven Development to an existing project.

      First, analyze the existing project structure:

      Tasks:
      1. Check if git repository exists (`.git/` directory)
      2. Identify primary language (check for `Cargo.toml`, `package.json`, `pyproject.toml`, etc.)
      3. Look for existing documentation (`README.md`, `docs/`, etc.)
      4. Check for existing test infrastructure
      5. Identify project structure patterns

      Report findings:
      - Git status: [exists/missing, current branch if exists]
      - Primary language: [detected language + version if available]
      - Existing docs: [list key files]
      - Test setup: [detected test framework/patterns]
      - Project structure: [key directories and organization]

      Then ask the user:
      "I've detected an existing [language] project. Before proceeding:
      1. Should I create a new branch for this retrofit? (recommended)
      2. Are there any existing conventions I should preserve?
      3. Any files or directories I should avoid modifying?"

      Respond with analysis and await user guidance.
    transitions:
      - when: "detection_complete"
        to: code_map

  code_map:
    prompt: |
      You are in the CODE_MAP phase (Retrofit Mode).

      {{CODE_MAP_WRITING}}

      Your task: Create CODE_MAP.md files to document existing codebase structure.

      Since this is a retrofit, you need to understand the existing codebase before adding DDD methodology.

      **First, assess project size:**
      - Count source files (exclude tests, configs, generated code)
      - If <50 files: Use monolithic structure (single root CODE_MAP.md)
      - If >50 files: Use hierarchical structure (one CODE_MAP per directory)

      **For monolithic structure:**
      - Single CODE_MAP.md at project root
      - Group files by category (Source Code, Tests, Configuration)
      - Brief descriptions (1-3 sentences per file)

      **For hierarchical structure:**
      - Create CODE_MAP.md for main source directory
      - Create CODE_MAP.md for each significant subdirectory
      - Non-recursive (each CODE_MAP only describes its direct children)
      - Reference subdirectory CODE_MAPs explicitly

      Ask the user:
      1. I detected [N] source files. Should I use [monolithic/hierarchical] structure?
      2. Which directories should I map? (e.g., src/, lib/, app/)
      3. Any directories to skip? (e.g., generated code, vendor deps)

      **Adversarial check**: What directories or patterns am I missing? Any unusual project structure I should understand?

      Respond when CODE_MAP files are created.
    transitions:
      - when: "code_map_complete"
        to: customize_claude

  customize_claude:
    prompt: |
      You are in the CLAUDE.md customization phase (Retrofit Mode).

      {{CLAUDE_CUSTOMIZATION}}

      Your task: Create CLAUDE.md integrating with existing project conventions.

      Since this is a retrofit, you should:
      - Start with Hegel DDD methodology template
      - Incorporate existing conventions you detected
      - Add project-specific patterns already in use
      - Document current testing approach
      - Preserve existing git workflow conventions

      Focus on:
      - Current testing philosophy (enhance, don't replace)
      - Existing code organization rules
      - Current git workflow (integrate DDD commits)
      - Existing tools and scripts
      - Language/framework patterns already in use

      Ask the user:
      1. Should I preserve existing testing conventions or establish new ones?
      2. Are current code organization rules working? Any changes needed?
      3. How should DDD commits integrate with existing git workflow?
      4. Any existing tools or patterns I should document?

      **Adversarial check**: What existing conventions am I overlooking? What might break if we change operational patterns?

      Respond with your completed CLAUDE.md content.
    transitions:
      - when: "claude_complete"
        to: vision

  vision:
    prompt: |
      You are in the VISION phase (Retrofit Mode).

      {{VISION_WRITING}}

      Your task: Create VISION.md or integrate with existing documentation.

      Since this is an existing project:
      - Check if vision/goals already documented elsewhere (README.md, docs/, etc.)
      - If documented: extract and formalize into VISION.md
      - If missing: work with user to define vision

      Focus on:
      - Existing problem statement (if any)
      - Current user base (who uses this now?)
      - Success criteria (how do we measure impact?)
      - Scope boundaries (what's in/out of scope?)
      - Design principles (stated or implied?)

      Ask the user:
      1. Does existing documentation capture project vision?
      2. If yes: Should I formalize it into VISION.md?
      3. If no: [Ask standard vision questions from greenfield]
      4. Has the project vision evolved? Any updates needed?

      **Adversarial check**: Am I missing existing project context? Does my vision align with current direction?

      Respond with your completed VISION.md content (or integration plan).
    transitions:
      - when: "vision_complete"
        to: architecture

  architecture:
    prompt: |
      You are in the ARCHITECTURE phase (Retrofit Mode).

      {{ARCHITECTURE_WRITING}}

      Your task: Document existing architecture or create ARCHITECTURE.md.

      Since this is an existing project:
      - Document current tech stack (what's actually in use)
      - Capture existing architectural patterns
      - Note any technical debt or constraints
      - Identify refactoring opportunities for Discovery

      Focus on:
      - Current technology stack (language, frameworks, key deps)
      - Existing architectural patterns (what works, what doesn't)
      - Known constraints (compatibility, performance, security)
      - Integration points (APIs, databases, services)
      - Open questions (what needs investigation/refactoring?)

      Ask the user:
      1. Any major architectural decisions to document?
      2. Technical debt that should be addressed?
      3. Dependencies that need evaluation/upgrade?
      4. Areas needing refactoring (candidates for Discovery)?

      **Adversarial check**: What architectural constraints am I missing? What technical risks should we document?

      Respond with your completed ARCHITECTURE.md content.
    transitions:
      - when: "architecture_complete"
        to: git_commit

  git_commit:
    prompt: |
      Retrofit initialization nearly complete.

      Final step: Commit DDD documentation to repository.

      Git workflow considerations (based on earlier detection):
      - If new branch was created: commit there
      - If on main/master: user approved direct commit

      Tasks:
      1. Create `.gitignore` entries for Hegel state (if not exists):
         - `.hegel/state.json`
         - `.hegel/hooks.jsonl`
         - `.hegel/states.jsonl`
      2. Stage CLAUDE.md, VISION.md, ARCHITECTURE.md
      3. Stage .gitignore updates (if any)
      4. Create commit: "docs: add DDD methodology documentation"

      After committing, inform the user:
      "DDD retrofit complete. Next steps:
      - Review CLAUDE.md, VISION.md, ARCHITECTURE.md
      - Run 'hegel start discovery' to explore first refactoring or feature
      - If on feature branch: consider creating PR for team review"

      Respond when git commit is complete.
    transitions: []
