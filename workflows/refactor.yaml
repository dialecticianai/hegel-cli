# Refactor workflow - focused code improvements
mode: refactor
start_node: review

nodes:
  review:
    summary: Collaborate with user to identify refactoring targets and analyze DRY/SoC violations.
    prompt: |
      You are in the REVIEW phase of the Refactor workflow.

      **CRITICAL: Start with discussion, not assumptions.**

      Your task: Collaborate with the user to identify what needs refactoring.
      {{?context_note}}

      **Step 1 - Ask the user:**
      - What specific areas of the codebase need refactoring?
      - What problems are they experiencing? (hard to navigate, repeated code, unclear structure)
      - What's the scope? (specific files/modules, or broader architectural concerns)
      - What's the goal? (token efficiency, clearer boundaries, extraction, splitting)

      **Step 2 - After understanding scope, analyze using these principles:**

      Refactoring purpose: Maximize token efficiency through DRY and SoC principles.

      **Primary focus areas:**

      1. **DRY (Don't Repeat Yourself) violations:**
         - Duplicated code blocks that could be extracted to helpers
         - Repeated patterns across multiple files/modules
         - Copy-pasted logic that increases token overhead
         - Similar implementations that could share abstractions

      2. **SoC (Separation of Concerns) violations:**
         - Mixed responsibilities in single files/functions
         - Files exceeding 200 lines that should be split into submodules
         - Business logic mixed with infrastructure code
         - Unclear module boundaries and responsibilities
         - God objects or modules doing too many things

      **Analysis approach:**
      - Identify high-token-cost patterns in the target area
      - Look for natural split points and extraction opportunities
      - Note which concerns are entangled and should be separated
      - Prioritize changes that maximize token efficiency

      **Out of scope (unless explicitly requested):**
      - Adding test coverage
      - Improving error handling
      - Performance optimization
      - Security hardening
      - Functionality changes

      **Step 3 - Document analysis:**
      - Write refactor analysis to `.ddd/refactor/<date>-<description>.md`
      - Include: files targeted, SoC/DRY violations identified, proposed splits, rationale, token savings
      - Use format: YYYYMMDD for date, snake_case for description
      - Run `hegel reflect .ddd/refactor/<filename>.md` to launch review GUI

      **Step 4 - Discuss findings with user:**
      - Present specific violations with file paths and line ranges
      - Propose refactoring approach and confirm before proceeding
      - Clarify priorities and scope boundaries

      Do not proceed to refactoring until the user confirms the plan.

      Respond when review discussion is complete and user approves proceeding.
    transitions:
      - when: "review_complete"
        to: refactor

  refactor:
    summary: Execute refactorings incrementally to maximize token efficiency while preserving functionality.
    prompt: |
      You are in the REFACTOR phase.

      **CRITICAL: Discuss changes before implementing.**

      Your task: Execute refactorings to maximize token-efficient legibility.
      {{?context_note}}

      **Before making changes:**
      - Review the approved plan from the REVIEW phase
      - Discuss specific implementation approach with the user
      - Confirm naming, module structure, and splitting strategy
      - Get approval before executing each major refactoring step

      **Refactoring requirements:**
      - Apply DRY: Extract duplicated code into helpers/abstractions
      - Apply SoC: Split large files (>200 lines) into focused submodules
      - Preserve existing functionality (all tests must still pass)
      - Keep commits atomic with clear descriptions
      - Update imports/re-exports for backwards compatibility

      **Common refactoring patterns:**
      - Extract repeated code into helper functions/modules
      - Split large files into submodules (one concern per module)
      - Factor out shared abstractions across similar implementations
      - Reorganize module structure for clearer boundaries
      - Create focused modules with single responsibilities

      **Critical constraints:**
      - DO NOT change functionality or behavior
      - DO NOT add new features or test coverage
      - DO NOT modify error handling or validation logic
      - DO maintain backwards compatibility through re-exports

      **Execution approach:**
      - Propose each refactoring step before executing
      - Show proposed module names, file structure, and responsibilities
      - Wait for user confirmation before proceeding
      - Execute incrementally, testing after each step
      - **CRITICAL: Commit after EACH completed step before advancing workflow**
      - Never batch multiple steps into a single commit

      **Commit workflow:**
      1. Complete a refactoring step (e.g., "Add function X to module Y")
      2. Run tests to verify step works
      3. Commit the step with descriptive message
      4. Verify user approval before next step
      5. Repeat for each step

      **Success criteria:**
      - All existing tests pass without modification
      - Token overhead reduced through DRY/SoC
      - Code structure more navigable and context-efficient
      - Each step committed atomically
      - User approves final structure

      Respond when refactoring is complete, all tests pass, all steps committed, and user approves.
    rules:
      - type: require_commits
        lookback_phases: 1
    transitions:
      - when: "refactor_complete"
        to: code_review

  code_review:
    summary: Update README code maps for refactored directories and commit the changes.
    prompt: |
      You are in the CODE_REVIEW phase of the Refactor workflow.

      {{CODE_MAP_WRITING}}

      Your task: Update README code maps for areas touched during refactoring.
      {{?context_note}}

      Focus on:
      - Identify which directories were modified during REFACTOR phase
      - Update README files with code map changes for those directories
      - In monolithic mode: Update the Code Structure section in root README.md
      - In hierarchical mode: Update or create README.md files for modified directories
      - Ensure descriptions accurately reflect current code structure
      - Keep descriptions concise (1-3 sentences per file)
      - Follow the code_map_style configured for this project
      - **CRITICAL: Commit README updates before completing phase**

      **Completion checklist:**
      1. Update all relevant README code maps
      2. Stage and commit README changes with descriptive message
      3. Verify all refactoring commits are clean and complete
      4. Confirm user approval

      Respond when README code map updates are complete and committed.
    rules:
      - type: require_commits
        lookback_phases: 1
    transitions:
      - when: "code_review_complete"
        to: done

  done:
    transitions: []
