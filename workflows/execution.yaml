# Execution mode workflow - optimized for production resilience
mode: execution
start_node: spec

nodes:
  spec:
    prompt: |
      You are in the SPEC phase of Document-Driven Development (Execution Mode).

      {{SPEC_WRITING}}

      Your task: Create a lean, focused behavioral contract through collaborative discovery.
      {{?context_note}}

      Execution mode focus:
      - Clear, minimal contracts that define core behavior
      - Happy path and essential error cases only
      - Test scenarios that drive TDD, not exhaustive edge case coverage
      - Simple acceptance criteria focused on working functionality
      - Keep it agile: specs should enable forward motion, not defensive programming

      **CRITICAL - Follow this sequence:**

      1. **Discovery Phase - Ground in actual codebase FIRST**:
         - Read existing code files for related functionality, types, and APIs
         - Check testing infrastructure (TESTING.md, test patterns)
         - Understand module organization and boundaries
         - Verify what external dependencies already provide (don't reinvent)
         - Note existing contracts, types, and patterns to match
         - If unsure about data availability, investigate before assuming
         - Document findings: what exists, what needs changing, what's missing

      2. **Discuss before writing**:
         - Use the SPEC_WRITING guide above to inform what questions to ask
         - Clarify constraints: Breaking vs. backward compatible? MVP vs. production-ready?
         - Clarify scope: Lean first pass? What's explicitly out of scope?
         - Validate architectural understanding: Are module boundaries correct?
         - Focus on WHAT needs to work, not every edge case that could break
         - Confirm type structures make sense (no redundancy, clean separation)
         - Gather missing context for a minimal viable spec

      3. **Write the spec**:
         - Only after discussion is complete, draft the SPEC.md
         - Reference actual file paths and existing types explicitly
         - Specify NEW vs. MODIFIED vs. REMOVED clearly
         - Mark uncertainties as "(TBD: verify)" rather than speculating
         - Keep it lean: core behavior, key scenarios, working functionality
         - Defer edge cases, performance tuning, advanced features to "Out of Scope"
         - Avoid over-engineering: no security hardening, no premature optimization
         - Success criteria must be agent-verifiable (tests pass, builds succeed, schemas match)
         - Separate subjective concerns into "Optional Human Testing" section
         - Incorporate insights from codebase review and user discussion
         - Respond with your completed SPEC.md content

      The guide is there to shape your questions, not to bypass discussion.
      Remember: Execution mode is agile and TDD-focused, not production-hardening.
    transitions:
      - when: "spec_complete"
        to: plan

  plan:
    prompt: |
      You are in the PLAN phase of Document-Driven Development (Execution Mode).

      {{PLAN_WRITING}}

      Your task: Create a lean, TDD-focused implementation plan.
      {{?context_note}}

      Execution mode approach:
      - TDD where it drives development forward (not for coverage metrics)
      - Core functionality first, edge cases only when essential
      - Integration points identified, not over-tested
      - Keep it agile: working code over defensive programming
      - Tests serve development, not audit requirements

      Respond with your completed PLAN.md content.
    transitions:
      - when: "plan_complete"
        to: code

  code:
    prompt: |
      You are in the CODE phase of Document-Driven Development (Execution Mode).

      Implement the system following the PLAN.md steps.
      {{?context_note}}

      Execution mode approach:
      - Tests that drive development, not exhaustive coverage
      - Error handling for real failure scenarios, not hypothetical ones
      - Working functionality over defensive programming
      - Clear code over premature optimization
      - Simple and direct over clever and general

      Respond when code is complete and all tests pass.
    rules:
      - type: repeated_command
        pattern: "cargo (build|check|test)"
        threshold: 5
        window: 120
      - type: repeated_file_edit
        path_pattern: "src/.*"
        threshold: 8
        window: 240
      - type: token_budget
        max_tokens: 8000
      - type: phase_timeout
        max_duration: 600
    transitions:
      - when: "code_complete"
        to: code_review

  code_review:
    prompt: |
      You are in the CODE_REVIEW phase of Document-Driven Development (Execution Mode).

      {{CODE_MAP_WRITING}}

      Your task: Update README code maps for areas touched during implementation.
      {{?context_note}}

      Focus on:
      - Identify which directories were modified during CODE phase
      - Update README files with code map changes for those directories
      - In monolithic mode: Update the Code Structure section in root README.md
      - In hierarchical mode: Update or create README.md files for modified directories
      - Ensure descriptions accurately reflect current code structure
      - Keep descriptions concise (1-3 sentences per file)
      - Follow the code_map_style configured for this project

      Respond when README code map updates are complete.
    transitions:
      - when: "code_review_complete"
        to: readme

  readme:
    prompt: |
      You are in the README phase of Document-Driven Development (Execution Mode).

      {{README_WRITING}}

      Your task: Create a UNIX man-style README.md.

      Include:
      - System overview and purpose
      - Installation and setup
      - API documentation
      - Usage examples
      - Error handling guide
      - Performance characteristics
      - Integration points

      Respond with your completed README.md content.
    transitions:
      - when: "readme_complete"
        to: done

  done:
    transitions: []